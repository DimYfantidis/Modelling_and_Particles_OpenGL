#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_WARNINGS

#include <time.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <Windows.h>
#include <GL/freeglut.h>

#include "globals.h"
#include "surface.h"
#include "particle.h"
#include "particle_list.h"

#define EDGE_SIZE		100.0f


surface worldSurfaces[2];
size_t n_surfaces;

// Checks if the particle p is directly above the surface S
bool areVerticallyAligned(const surface* S, const particle* p)
{
	// Compute the surface's projection on the Y=0 plane (centered at the origin)
	point3d sides[4] = {
		{S->vertices[0][0] - p->position[0], .0f, S->vertices[0][2] - p->position[2]},
		{S->vertices[1][0] - p->position[0], .0f, S->vertices[1][2] - p->position[2]},
		{S->vertices[2][0] - p->position[0], .0f, S->vertices[2][2] - p->position[2]}, 
		{S->vertices[3][0] - p->position[0], .0f, S->vertices[3][2] - p->position[2]}
	};

	// lengths of each side
	double lengths[4] = {
		vectorLength3d(sides[0]),
		vectorLength3d(sides[1]),
		vectorLength3d(sides[2]),
		vectorLength3d(sides[3])
	};
	double angle_sum;

	// Calculate the angle of the triangle formed by the origin (point) and one side.
	// If the sum is 360 degrees, then the point is above the surface
	angle_sum = acos(innerProduct3dv(sides[0], sides[1]) / (lengths[0] * lengths[1]));
	angle_sum += acos(innerProduct3dv(sides[1], sides[3]) / (lengths[1] * lengths[3]));
	angle_sum += acos(innerProduct3dv(sides[3], sides[0]) / (lengths[3] * lengths[0]));

	if (doubleEquals(angle_sum, 2.0 * M_PI))
		return true;

	// Repeat for the other sub-triangle
	angle_sum = acos(innerProduct3dv(sides[1], sides[2]) / (lengths[1] * lengths[2]));
	angle_sum += acos(innerProduct3dv(sides[2], sides[3]) / (lengths[2] * lengths[3]));
	angle_sum += acos(innerProduct3dv(sides[3], sides[1]) / (lengths[3] * lengths[1]));

	if (doubleEquals(angle_sum, 2.0 * M_PI))
		return true;

	return false;
}

bool collisionDetection(const surface *S, const particle* p)
{
	// Choose a random point on the surface -- e.g.: S->vertices[0]
	vector3f diff = { 
		p->position[0] - S->vertices[0][0],
		p->position[1] - S->vertices[0][1],
		p->position[2] - S->vertices[0][2]
	};
	return innerProduct3fv(S->normal, diff) < 0.2f;
}

inline void collisionResolution(const surface* S, particle* p)
{
	// Reflection vector formula (elastic)
	float collisionFactor = innerProduct3fv(p->velocity, S->normal);
	p->velocity[0] = -2.0f * collisionFactor * S->normal[0] + p->velocity[0];
	p->velocity[1] = -2.0f * collisionFactor * S->normal[1] + p->velocity[1];
	p->velocity[2] = -2.0f * collisionFactor * S->normal[2] + p->velocity[2];
}

void castShadow(const surface* S, const particle* p)
{
	if (floatEquals(S->normal[1], 0.0f))
		return;

	bool collisionX = p->position[0] > S->min[0] && p->position[0] < S->max[0];
	bool collisionZ = p->position[2] > S->min[2] && p->position[2] < S->max[2];

	if (!collisionX || !collisionZ)
		return;

	float y_shadow = (-S->normal[0] * (p->position[0] - S->vertices[0][0]) - S->normal[2] * (p->position[2] - S->vertices[0][2])) / S->normal[1] + S->vertices[0][1];

	glColor3f(0.03f, 0.03f, 0.03f);
	glVertex3f(p->position[0], y_shadow + 0.05f, p->position[2]);
}

// Worker thread for generating particles
HANDLE particleGeneratorThread;
// ID of the worker thread
DWORD particleGeneratorId;
// Mutex for restricting write access to the particle list -- Up to one writer allowed
HANDLE particleListGuard;

/* Abstract data-structure of dynamic size. 
 * Contains every particle generated by the worker thread.
 * - Insertion time: O(1)
 * - Deletion time: O(1)
 * - Space: O(n_particles) */
list particleList;

// Variables of the parametric surface (sphere) on which the camera moves.
static double v_angle = 45.0;
static double h_angle = 0.0;
static double radius = 60.0;

// Camera's poistion in the world -- consistent with the sphere's parametric equation
static double cameraPosition[3] = { 0.0f, M_SQRT2 / 2.0, M_SQRT2 / 2.0 };
// The point-location where the particles spawn at
static point3f spawn_pos = { 0.0f, 40.0f, 0.0f };


// Updates the camera position according to the updated surface parameters
void updateCamera(void)
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-radius, radius, -radius, radius, -radius - 40.0, radius + 40.0);
	// Camera stares at the world's center
	gluLookAt(cameraPosition[0], cameraPosition[1], cameraPosition[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
}

// Worker thread's function -- attempts to insert a new particle every 50ms
DWORD WINAPI particleGeneratorWorker(LPVOID lpParam)
{
	while (true)
	{
		// Requests write access to the particle lists
		WaitForSingleObject(particleListGuard, INFINITE);
		// Inserts a new particle to the list
		appendToList(&particleList, generateParticle(spawn_pos, 5.2f));
		// Release's lists write access to the next writer
		ReleaseMutex(particleListGuard);
		Sleep(50);
	}
	return 0;
}

// Display function -- main program
void display(void)
{
	// Time recording variables to compute deltaTime
	static clock_t startTime = ((clock_t)0);
	static clock_t endTime = ((clock_t)0);
	// Gravitational acceleration vector
	static vector3f gravity = { 0.0f, -9.80665f, 0.0f };
	// String buffer for on-screen logging of the system's state
	static char screenLogBuffer[100];

	startTime = clock();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	updateCamera();
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// Display all surfaces
	glColor3f(0.1f, 0.1f, 0.1f);
	for (size_t i = 0; i < n_surfaces; ++i) {
		drawSurface(&worldSurfaces[i]);
	}

	// Display all points
	glBegin(GL_POINTS);
	{
		particle* p;
		list_node* nextNode;

		for (list_node* currentNode = particleList.head; currentNode != NULL; currentNode = nextNode)
		{
			// Fetch current point
			p = currentNode->data;

			// Draw current point
			glColor3f(1.0f, 1.0f, 1.0f);
			glVertex3fv(p->position);

			for (size_t i = 0; i < n_surfaces; ++i)
			{
				// Check if the point is above a given surface
				if (areVerticallyAligned(&worldSurfaces[i], p))
				{
					// If yes, cast its shadow onto the given surface and check for collision
					castShadow(&worldSurfaces[i], p);
					if (collisionDetection(&worldSurfaces[i], p))
						collisionResolution(&worldSurfaces[i], p);
				}
			}
			// Fetch the following particle node
			nextNode = currentNode->next;
			
			if (isInsideWorldLimits(p))
				// Apply physics to the particle if it's inside the world
				accelerate3fv(p, gravity, airResistance);
			else
			{
				// Else deallocate its resources to avoid bugs and performance drops
				WaitForSingleObject(particleListGuard, INFINITE);
				removeFromList(&particleList, currentNode);
				ReleaseMutex(particleListGuard);
			}
		}
	}
	glEnd();

	// Log system's state
	snprintf(screenLogBuffer, sizeof(screenLogBuffer) / sizeof(char), "Total Points (currently): %zu", particleList.size);
	renderString2f(3.0f, 15.0f, GLUT_BITMAP_9_BY_15, screenLogBuffer, 1.0f, 1.0f, 1.0f);
	snprintf(screenLogBuffer, sizeof(screenLogBuffer) / sizeof(char), "FPS: %.3lf", (1.0 / deltaTime));
	renderString2f(3.0f, 30.0f, GLUT_BITMAP_9_BY_15, screenLogBuffer, 1.0f, 1.0f, 1.0f);
	snprintf(screenLogBuffer, sizeof(screenLogBuffer) / sizeof(char), "Air Resistance: %s", airResistanceStr);
	renderString2f(3.0f, 45.0f, GLUT_BITMAP_9_BY_15, screenLogBuffer, 1.0f, 1.0f, 1.0f);
	snprintf(screenLogBuffer, sizeof(screenLogBuffer) / sizeof(char), "Drag Coefficient: %.4f", particleDragCoefficient);
	renderString2f(3.0f, 60.0f, GLUT_BITMAP_9_BY_15, screenLogBuffer, 1.0f, 1.0f, 1.0f);

	// Draw
	glutSwapBuffers();

	endTime = clock();
	// Compute time interval for the rendering of the frame
	deltaTime = (double)(endTime - startTime) / CLOCKS_PER_SEC;
	deltaTimeF = (float)deltaTime;
}

int x_prev = 0;
int y_prev = 0;

/*
*	The camera/observer moves on the unary sphere with
*	its center being the origin of the axes
*		C: x^2 + y^2 z^2 = 1
*	Parametric expression:
*		- C: [x(u,v)]^2 + [y(u,v)]^2 [z(u,v)]^2 = 1
*		- x(u,v) = cos(u) * sin(v)
*		- y(u,v) = sin(u)
*		- z(u,v) = cos(u) * cos(v)
*/
void motion(int x, int y)
{
	int dx = x - x_prev;
	int dy = y - y_prev;

	static GLdouble angle_rad_horizontal = 0.0f;
	static GLdouble angle_rad_vertical = 0.0f;

	static const GLdouble ROTATION_STEP = 0.4;

	if (dx != 0)
	{
		h_angle -= dx * ROTATION_STEP;
		if (h_angle >= 360.0) {
			h_angle -= 360.0;
		}
		if (h_angle <= 0.0) {
			h_angle += 360.0;
		}
	}
	if (dy != 0)
	{
		v_angle += dy * ROTATION_STEP;
		if (v_angle >= 89.0) {
			v_angle = 89.0;
		}
		if (v_angle <= -89.0) {
			h_angle = -89.0;
		}
	}
	angle_rad_horizontal = h_angle * M_PI / 180.0;	// v angle
	angle_rad_vertical = v_angle * M_PI / 180.0;	// u angle

	// x(u, v) = cosu * sinv
	cameraPosition[0] = cos(angle_rad_vertical) * sin(angle_rad_horizontal);
	// y(u, v) = sinu
	cameraPosition[1] = sin(angle_rad_vertical);
	// z(u, v) = cosu * cosv
	cameraPosition[2] = cos(angle_rad_vertical) * cos(angle_rad_horizontal);

	x_prev = x;
	y_prev = y;

	glutPostRedisplay();
}

void mouseWheel(int button, int dir, int x, int y)
{
	radius -= 2* dir;
}

void mouse(int button, int state, int x, int y)
{
	if (button == GLUT_LEFT_BUTTON)
	{
		if (button == GLUT_DOWN)
		{
			x_prev = x;
			y_prev = y;
			glutMotionFunc(motion);
		}
		else
		{
			glutMotionFunc(NULL);
		}
	}
}

void keyboard(unsigned char key, int x, int y)
{
	key = tolower(key);

	if (key == 'r') 
	{
		WaitForSingleObject(particleListGuard, INFINITE);
		destroyList(&particleList, false);
		initList(&particleList);
		ReleaseMutex(particleListGuard);
	}
	else if (key == 'a')
	{
		airResistance = !airResistance;
		strcpy(airResistanceStr, (airResistance ? "Enabled" : "Disabled"));
	}
}

void specialKey(int key, int x, int y)
{
	if (key == GLUT_KEY_UP) {
		particleDragCoefficient *= 1.1f;
	}
	else if (key == GLUT_KEY_DOWN) {
		if (particleDragCoefficient / 1.1 != .0)
			particleDragCoefficient /= 1.1f;
	}
}

// Reshape function for resizing the window dynamically according to the user.
void reshape(int width, int height)
{
	WINDOW_WIDTH = width;
	WINDOW_HEIGHT = height;

	WINDOW_WIDTH_HALF = WINDOW_WIDTH / 2;
	WINDOW_HEIGHT_HALF = WINDOW_HEIGHT / 2;

	glViewport(0, 0, width, height);
}

void cleanupFunc(void)
{
	WaitForSingleObject(particleListGuard, INFINITE);
	WaitForSingleObject(particleGeneratorThread, 2);
	ReleaseMutex(particleListGuard);

	CloseHandle(particleGeneratorThread);
	CloseHandle(particleListGuard);

	destroyList(&particleList, true);
}

void tickRedisplay(int value) 
{
	// Draws the next frame according to the current framerate
	glutPostRedisplay();
	glutTimerFunc((int)(1000 * deltaTime), tickRedisplay, 0);
}

void main_menu(int op_id)
{
	switch (op_id)
	{
	case 1:
		n_surfaces = 1;

		initSurface12f(&worldSurfaces[0],
			-EDGE_SIZE / 2, 0.0f, -EDGE_SIZE / 2,
			EDGE_SIZE / 2, 0.0f, -EDGE_SIZE / 2,
			EDGE_SIZE / 2, 0.0f, EDGE_SIZE / 2,
			-EDGE_SIZE / 2, 0.0f, EDGE_SIZE / 2
		);
		spawn_pos[0] = 0.0f;
		spawn_pos[1] = 40.0f;
		spawn_pos[2] = 0.0f;
		break;
	case 2:
		n_surfaces = 1;

		initSurface12f(&worldSurfaces[0],
			-50.0f, 0.0f, -50.0f,
			50.0f, 0.0f, 0.0f,
			-50.0f, 0.0f, 50.0f,
			0.0f, 0.0f, 0.0f
		);
		spawn_pos[0] = 0.0f;
		spawn_pos[1] = 40.0f;
		spawn_pos[2] = 0.0f;
		break;
	case 3:
		n_surfaces = 2;

		initSurface12f(&worldSurfaces[0],
			-20.0f, 40.0f, -40.0f,
			20.0f, 40.0f, -40.0f,
			20.0f, 20.0f, 0.0f,
			-20.0f, 20.0f, 0.0f
		);

		initSurface12f(&worldSurfaces[1],
			0.0f, 40.0f, 60.0f,
			-20.0f, 40.0f, 40.0f,
			0.0f, 0.0f, 20.0f,
			20.0f, 0.0f, 40.0f
		);

		spawn_pos[0] = 0.0f;
		spawn_pos[1] = 60.0f;
		spawn_pos[2] = -20.0f;
		break;
	case 4:
		break;
	default:
		printf("Error: Reached unreachable state\n");
		exit(EXIT_FAILURE);
	}
	glutPostRedisplay();
}

// Main menu
void create_window_menu(void)
{
	window_menu_id = glutCreateMenu(main_menu);
	{
		glutAddMenuEntry("1. Default ground", 1);
		glutAddMenuEntry("2. Arrow ground", 2);
		glutAddMenuEntry("3. Fun park", 3);
		glutAddMenuEntry("Return to 1st Question", 4);
	}
	glutAttachMenu(GLUT_RIGHT_BUTTON);
}


int main(int argc, char* argv[])
{
	srand((unsigned int)time(NULL));

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGB);
	glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);
	glutCreateWindow("Dimitrios Yfantidis - 3938");

	create_window_menu();

	WINDOW_WIDTH_HALF = WINDOW_WIDTH / 2;
	WINDOW_HEIGHT_HALF = WINDOW_HEIGHT / 2;

	initList(&particleList);

	main_menu(1);

	if ((particleListGuard = CreateMutex(NULL, FALSE, NULL)) == NULL)
	{
		printf("CreateMutex failed (%d)\n", GetLastError());
		return EXIT_FAILURE;
	}

	if ((particleGeneratorThread = CreateThread(NULL, 0, particleGeneratorWorker, (LPVOID)1, 0, &particleGeneratorId)) == NULL)
	{
		printf("CreateThread failed (%d)\n", GetLastError());
		return EXIT_FAILURE;
	}

	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_POINT_SMOOTH);

	glPointSize(6.0f);
	glEnable(GL_POINT_SMOOTH);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glutTimerFunc(6, tickRedisplay, 0);
	glutMouseFunc(mouse);
	glutMouseWheelFunc(mouseWheel);
	glutReshapeFunc(reshape);
	glutDisplayFunc(display);
	glutCloseFunc(cleanupFunc);
	glutKeyboardFunc(keyboard);
	glutSpecialFunc(specialKey);
	glutMainLoop();

	return EXIT_SUCCESS;
}